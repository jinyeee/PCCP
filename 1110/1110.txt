6 6
0 0 0 0 0 0
0 2 0 1 0 0
0 2 0 1 0 1
0 0 0 0 1 2
0 1 2 0 0 0
0 0 2 2 1 0


입력에서 첫번째 줄은 행 렬의 개수입니다.

1. 2와 근접해 있는 1의 개수는? ( 근접 : 상하좌우)

2. 1과 근접해 있는 2의 개수는?

3. 중심을 기준으로 1칸씩 합친 십자 모양을 더했을 때 가장 큰 수는?(총 5 칸)

4.중심을 기준으로 끝 합친 십자 모양을 더했을 때 가장 큰 수는?(총 11칸)

-------------------------------------------------------------------------------------
dfs - stack
bfs - que

cs에 가까움
데이터 구조 

데이터간의 연결관계 -> 그래프

Class node
   갈 수 있는 node 

1. 인접 리스트
2. 인접 행렬

- 인접리스트
1. 리스트 생성
각 인덱스에 해당된 노드의 인접한 노드 번호를 리스트에 넣는다..?
내가 갈 수 있는 노드들을 작성
리스트를 보고도 노드의 형태를 유추할 수 있다.

노드에 번호 부여 


-인접 행렬



데이터 탐색
(x,y)      (i, j) (r,c)
nx, ny 


규칙성을 파악해서 index에 따라 다른 값을 부여

x, y = 1, 1
dx = [0, 0,1, -1]
dy  = [ 1, -1, 0, 0]

for d in range(4):
	nx = x + dx[d]
	ny = y + dy[d]

# 문제 풀기

입력받아서 행렬 생성 
1. 행렬 생성
2. 
for if count 사용

- 확인한 숫자가 2이면, 2 근처의 숫자가 1인지 확인
만든 행렬을 돌면서 

dx = [0,0,1,-1]
dy = [y, y-2, y-1, y-1]

if n == 2:
 for d in range(4):
     nx = x + dx[d]
     ny = y + dy[d]
      # 인덱스가 (nx, ny) 숫자가 1인지 확인
         if lst[nx, ny] == 1:
         cnt += 1 





-------------------

1의 개수이면서 2에 근접해야한다. -> 2가지 조건 충족

# 입력을 먼저 받는다. ( 문제를 많이 풀면서 습관적으로 나와야한다.)
n, m = map(int, input().split())
mat = [list(map(int, input().split())) for _ in range]


for i in range(n):
   for j in range(m):
      # 1의 개수를 count
      if mat[i][j] == 1:
       # 2에 근접할 경우!
         for d in rnage(d):
             ni = i + di[d]
             nj = j + dj[d]
             #ni, nj를 방문할 수 있는지를 판단
	 
	 # 방문할 수 있는 경우

             if mat[ni][nj]n== 2
             cnt += 1 





# 근접한 숫자를 구할거니 cnt를 해주고 break를 해주면된다.
중복되는 경우를 방지


-------------------------------------------
stack - 선입후출 append pop
que - 순서대로 선입선출
 
리스트
메모리상으로 주소값은 고정되어있지만
순서를 새로 배정받는 것처럼 느껴진다
ex) pop(0)을 해주면 첫번째 값이 사라지고 순서가 바뀌는것같지만
메모리상 주소값은 변하지 않고 고정되어 있다.

링크드리스트
 data / 다음 노드의 주소 -> data / 다음 노드의 주소
잘라도 크게 상관이 없다
자른 형태 그대로 리스트 형태가 변화..?

# 리스트
# 여러개의 데이터를 순서가 있도록 저장

# 스택
# 리스트는 리스트인데, 한 방향으로 데이터의 삽입, 삭제가 잦은 자료 구조

덱(deque)
double ended queue


한방향으로 탐색 -> dfs
근접한 순서로 탐색 -> bfs

que는 사용하면 버려 
방문할 곳 뒤에 적재
방문한 곳은 버려

stack
버리지않고 갈수있는곳을 적고
그 다음 갈수있는곳이 없으면 버려



list 

재귀함수
콜스택에 쌓일수있다


코딩테스트 공부를 단계별로 하면 되는지
알고리즘 공부는 어떤식으로 하면 좋은지
제일 중요한 우선순위가 뭐라고 생각하시는지


